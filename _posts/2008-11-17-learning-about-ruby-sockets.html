---
layout: post
title: Learning About Ruby Sockets
published: true
---
I have been reading this: <a href="https://www6.software.ibm.com/developerworks/education/l-rubysocks/l-rubysocks-a4.pdf">https://www6.software.ibm.com/developerworks/education/l-rubysocks/l-rubysocks-a4.pdf</a><br /><div class="CodeRay">
  <div class="code"><pre>Sockets programming in RubyExplore Ruby's fundamental sockets interfaces for networkingapplicationsSkill Level: IntermediateM. Tim Jones (mtj@mtjones.com)Senior Principal Software EngineerEmulex Corp.</pre></div>
</div>
<br />I am pulling out text and putting it here that is relevant to me for later use.  Basically this post is my note taking system...<p />You can create a stream server socket using the TCPServer class. To this method, you provide the address to which you'll bind the port. In most cases, you bind to the INADDR_ANY ("0.0.0.0"), which lets you accept connections from any of the available interfaces on the host. This can be done in the following ways (binding to port 23000):<p />Listing 5. Creating a stream server socket (theses two are the same)<br /><code>servSock = TCPServer::new( "0.0.0.0", 23000 )</code><br /><code>servSock = TCPServer::new( "", 23000 )</code><p />Note that the bind and listen are done for you as part of the TCPServer socket<br />creation.<p />Listing 6. Closing a socket<br /><code>servSock::close</code><p />Once the server socket is established it is possible to create a new socket upon incoming connections.<p /><code>newsock = servSock.accept</code><p />Now you can read and write to the new socket.<p /><code>msg = newsock.read</code><br /><code>newsock.write("You are connected.\n")</code><p />Here is the script I modified from the above document:<p /><div class="CodeRay">
  <div class="code"><pre>require 'socket'class Connection  def initialize( port )    @descriptors = Array::new    @serverSocket = TCPServer.new( &quot;&quot;, port )    @serverSocket.setsockopt( Socket::SOL_SOCKET, Socket::SO_REUSEADDR, 1 )    printf(&quot;Now listening on port %d\n&quot;, port)    @descriptors.push( @serverSocket )  end    def run    while 1      res = select( @descriptors, nil, nil, nil )      if res != nil then        # Iterate through the tagged read descriptors        for sock in res[0]          # Received a connect to the server (listening) socket          if sock == @serverSocket then            puts &quot;Accepting new connection. \n&quot;            accept_new_connection          else            # Received something on a client socket            if sock.eof? then              str = sprintf(&quot;Client left %s:%s\n&quot;, sock.peeraddr[2], sock.peeraddr[1])              printf(str)              #broadcast_string( str, sock )              sock.close              @descriptors.delete(sock)            else              str = sprintf(&quot;[%s|%s]: %s\n&quot;, sock.peeraddr[2], sock.peeraddr[1], sock.gets() )              #broadcast_string( str, sock )              printf(str)            end          end        end      end    end  end    def end_connection    @serverSocket.close    @descriptors = []  end    private    def accept_new_connection    newsock = @serverSocket.accept_nonblock    @descriptors.push( newsock )        #newsock.write(&quot;You're connected to the Ruby chatserver\n&quot;)        str = sprintf(&quot;Client joined %s:%s\n&quot;, newsock.peeraddr[2], newsock.peeraddr[1])    printf(str)                   #broadcast_string( str, newsock )  end    def broadcast_string( string, omit_sock )    @descriptors.each do |clisock|      if clisock != @serverSocket &amp;&amp; clisock != omit_sock        clisock.write(string)      end    end    print(string)  endend</pre></div>
</div>
<div class="blogger-post-footer"><img class="posterous_download_image" src="https://blogger.googleusercontent.com/tracker/7696555460565635585-6107233214362071897?l=www.jet5ive.com" height="1" alt="" width="1" /></div>
